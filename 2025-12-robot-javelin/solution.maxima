/* vim:filetype=maxima:et:sw=4:
 */

/* UPDATE: it is possible to compute a diff when otherwise maxima can't do it. */
/* m2(a, b) := (b-a) * unit_step(b-a); */
m2(a, b) := m_(b - a);

m_(x) := if x >= 0 then x else 0;
/* Maxima can't compute diff of above. We can however make it a noun (to leave it unevaluated) and provide the diff
 * ourselves. Below is slightly inaccurate, as m_(x) is not differentiable at x=0, but p_A_less_B is probably smooth
 * enough.
 */
declare(m_, noun);
/* Well, while this works for a single-variable function, there is still a problem for expressions involving max/min.
 * gradef(m_(x), if x >= 0 then 1 else 0);
 */

p_A_less_B: apply("+", makelist(concat(part, i), i, 8));
part1: 1/2 * m2(dx, da) * dh;
part2: 1/2 * (1 - max(dx, da))^2 * dh;
part3: 1/2 * (1 - dh^2) * m2(dx, da);
part4: 1/2 * ((1 - max(dx, da))^2 - m2(max(dx, da), dh)^2);
part5: 1/2 * min(dx, da) * dl;
part6: 1/2 * m2(da, dx) * (2 - da - dx) * dl;
part7: 1/2 * (1 - dl^2) * min(da, dx);
part8: 1/2 * (m2(da, dx) * (2 - da - dx) - m2(da, min(dl, dx)) * (m2(dx, dl) + m2(da, dl)));

/* Assumptions are necessary to get a nice result, and to get a result at all when computing diff. Without them, Maxima
 * can't compute the diff symbolically, which is expected, given that unit_step() is not differentiable at 0. However,
 * Maxima even has trouble when computing a value of such diff at given point, which should be doable using at(), but
 * somehow it needs to have the symbolic diff computed first.
 */
assume(da>0, da<1);
assume(db>0, db<1);
assume(dx>0, dx<1);
assume(dh>0, dh<1);
assume(dl>0, dl<1);

/* verify P(A<B) when db>da */
assume(db>da);
/* We substitute vars in general P(A<B) to get the simple case, without Spears Robot cheating.
   Then we compare it with manually calculated result for the simple case.
   It actually revealed a bug.
*/
if not equal(ev(ev(p_A_less_B), dx=0, dh=db, dl=db), 1/2*(-(da+1)*db^2+(da^2+da+1)*db-da+1)) then error("Incorrect result for the simple case") else OK;
forget(db>da);

plot3d(ev(ev(p_A_less_B), dx=0, dh=db, dl=db), [da, 0, 1], [db, 0, 1]);

/* equilibrium */
d_eq: (sqrt(5)-1)/2;

order_ev(x, y) := ev(x) < ev(y);
    /*print("before ev(expr), facts are", facts()),*/
assume_and_eval(da, dx, dh, dl, 'expr) := block([da_:da, dx_:dx, dh_:dh, dl_:dl, vord:sort(['da, 'dx, 'dh, 'dl], 'order_ev)],
    kill(da, dx, dh, dl),
    context:tempc,
    apply(assume, makelist(vord[i]<vord[i+1], i, length(vord)-1)),
    result:ev(expr),
    killcontext(tempc),
    result
);

p_A_less_B_fun(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, ev(ev(p_A_less_B, eval), [da=da_, dx=dx_, dh=dh_, dl=dl_]));
/* should yield the same plot */
plot3d(subst([dx=0, dh=db, dl=db], 'p_A_less_B_fun(da, dx, dh, dl)), [da, 0, 1], [db, 0, 1]);

grad_da_straightforward_BAD(da_, dx_, dh_, dl_) := at(diff(ev(p_A_less_B, eval), da), [da=da_, dx=dx_, dh=dh_, dl=dl_]);

grad_da(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, at(diff(ev(p_A_less_B, eval), da), [da=da_, dx=dx_, dh=dh_, dl=dl_]));
grad_dx(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, at(diff(ev(p_A_less_B, eval), dx), [da=da_, dx=dx_, dh=dh_, dl=dl_]));
grad_dh(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, at(diff(ev(p_A_less_B, eval), dh), [da=da_, dx=dx_, dh=dh_, dl=dl_]));
grad_dl(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, at(diff(ev(p_A_less_B, eval), dl), [da=da_, dx=dx_, dh=dh_, dl=dl_]));

is(grad_da(0.5, 0, 0.5, 0.5) = -0.125);
is(grad_da_straightforward_BAD(0.5, 0, 0.5, 0.5) = -0.125);

load("lbfgs");
estimates: lbfgs(subst(da=d_eq, '[-p_A_less_B_fun(da, dx, dh, dl), [-grad_dx(da, dx, dh, dl), -grad_dh(da, dx, dh, dl), -grad_dl(da, dx, dh, dl)]]), [dx, dh, dl], [0.5, 0.5, 0.5], 1e-4, [1, 0]);
/*
 THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
 IFLAG = 0
(%o34) [dx = 0.6181829933081731, dh = 0.6911577540600253, dl = 0.5000486022046384]
*/

/* Solve analytically for Spears Robot. We need to evaluate our formula with assumptions as for the expected range of optimum. */
context:tempc;
assume(dl<da and da<dx and dx<dh);
print("Solving analytically for Spears Robot with assumptions:", facts())$
expr: ratsimp(subst(da=d_eq, ev(p_A_less_B, eval)));
solutions: solve(map(lambda([x], diff(expr, x)), [dx, dh, dl]), [dx, dh, dl]);
killcontext(tempc);

/* Verify numeric estimates and analytic solutions. */
for vars in append([estimates], solutions) do (
    vars: cons(da=d_eq, vars),
    print("Checking solution for Spears Robot:", ev(vars, numer)),
    val1: ev(ev(ev(p_A_less_B), vars), numer), /* for Spears Robot */
    print("Probability for Spears Robot is:", val1),
    print("Assumptions satisfied:", ev(is(dl<da and da<=dx and dx<dh), vars)),
    print("-------")
)$

solution_spears: solutions[2];

(
    vars: cons(da=d_eq, solution_spears),
    print("Final solution for Spears Robot:", ev(vars, numer)),
    val1: ev(ev(ev(p_A_less_B), vars), numer), /* for Spears Robot */
    print("Probability for Spears Robot is:", val1),
    print("Assumptions satisfied:", ev(is(dl<da and da<=dx and dx<dh), vars)),
    print("-------")
)$

/************************************************************************************************************************
 * Previously we maximized P(A<B). We now need to maximize probability for Java-lin, which is 1-P(A<B), by minimizing
 * P(A<B) over da, using previously computed optimal (for Spears Robot) dx, dh, dl, stored in solution_spears.
************************************************************************************************************************/
plot2d(subst(solution_spears, 'p_A_less_B_fun(da, dx, dh, dl)), [da, 0, 1]);
estimates: lbfgs(subst(solution_spears, '[p_A_less_B_fun(da, dx, dh, dl), [grad_da(da, dx, dh, dl)]]), [da], [0.5], 1e-4, [1, 0]);

/* Solve analytically for Java-lin. We need to evaluate our formula with assumptions as for the expected range of optimum. */
context:tempc;
assume(dl<da and da<dx and dx<dh);
print("Solving analytically for Java-lin with assumptions:", facts())$
expr: ratsimp(subst(solution_spears, ev(p_A_less_B, eval)));
/* There is just one solution, let's wrap it in a list so that below code looks similar to that for Spears Robot. */
solutions: [solve(map(lambda([x], diff(expr, x)), [da]), [da])];
killcontext(tempc);

/* Verify numeric estimates and analytic solutions. */
for vars in append([estimates], solutions) do (
    vars: append(solution_spears, vars),
    print("Checking solution for Java-lin:", ev(vars, numer)),
    val0: ev(ev(ev(p_A_less_B), vars), numer), /* for Spears Robot */
    val1: ev(ev(ev(1 - p_A_less_B), vars), numer), /* for Java-lin */
    print("Probability for Spears Robot is:", val0),
    print("Probability for Java-lin is:", val1),
    print("Assumptions satisfied:", ev(is(dl<da and da<=dx and dx<dh), vars)),
    print("-------")
)$

solution_javalin: solutions[1];

(
    vars: append(solution_spears, solution_javalin),
    print("Final solution for Java-lin:", ev(vars, numer)),
    val0: ev(ev(ev(p_A_less_B), vars), numer), /* for Spears Robot */
    val1_exact: ev(ev(1 - p_A_less_B), vars), /* for Java-lin */
    print("Probability value for Spears Robot is:", val0),
    print("Probability for Java-lin is:", ratsimp(ev(val1_exact))),
    print("Probability value for Java-lin is:", ev(val1_exact, numer)),
    print("Assumptions satisfied:", ev(is(dl<da and da<=dx and dx<dh), vars)),
    print("-------")
)$

print("Probability value for Java-lin rounded to 10 places is:", ev(round(val1_exact * 10^10) / 10^10, numer))$
