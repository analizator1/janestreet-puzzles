/* vim:filetype=maxima:et:sw=4:
 */

/* Set format to gnuplot (defaults to gnuplot_pipes), which should be run synchronously, to make sure plot windows are
 * shown in their separate, persistent windows (unlike gnuplot_pipes) when using Maxima in batch mode.
 * Unfortunately Maxima 5.46.0 has a bug with 3d plots, and with "gnuplot" format it won't show plots at all
 * (gnuplot_pipes is not affected).
 */
/*set_plot_option([plot_format, gnuplot]);
get_plot_option(plot_format);*/

/* Make sure conditionals get evaluated for some assertions using error(). */
prederror: true;

 /* Measure of [a; b] interval. */
 m(a, b) := max(b-a, 0);

/* General case, with Spears Robot (B) cheating against Java-lin (A).
 * We compute P(A<B) by splitting it into 8 parts, calculated by hand. */
p_A_less_B: apply("+", makelist(concat(part, i), i, 8));

/* Cases where A1>=dx. This is the information that leaks to Spears Robot. */
/* P(A<B and A1<da and B1<dh and A1>=dx) */
part1: 1/2 * m(dx, da) * dh;
/* P(A<B and A1>=da and B1<dh and A1>=dx) */
part2: 1/2 * (1 - max(dx, da))^2 * dh;
/* P(A<B and A1<da and B1>=dh and A1>=dx) */
part3: 1/2 * (1 - dh^2) * m(dx, da);
/* P(A<B and A1>=da and B1>=dh and A1>=dx) */
part4: 1/2 * ((1 - max(dx, da))^2 - m(max(dx, da), dh)^2);

/* Cases where A1<dx */
/* P(A<B and A1<da and B1<dl and A1<dx) */
part5: 1/2 * min(dx, da) * dl;
/* P(A<B and A1>=da and B1<dl and A1<dx) */
part6: 1/2 * m(da, dx) * (2 - da - dx) * dl;
/* P(A<B and A1<da and B1>=dl and A1<dx) */
part7: 1/2 * (1 - dl^2) * min(da, dx);
/* P(A<B and A1>=da and B1>=dl and A1<dx) */
part8: 1/2 * (m(da, dx) * (2 - da - dx) - m(da, min(dl, dx)) * (m(dx, dl) + m(da, dl)));

/* Evaluate to get rid of partX in p_A_less_B. Later, we need ev(p_A_less_B, noeval) only to simplify the expression after we
 * assume() something. In newer versions of Maxima there is resimplify() function.
 */
p_A_less_B: ev(p_A_less_B);

assume(da>0, da<1);
assume(db>0, db<1);
assume(dx>0, dx<1);
assume(dh>0, dh<1);
assume(dl>0, dl<1);

/* Simple formula, when Spears Robot is not cheating. Calculated by hand. */
p_A_less_B_simple: 1/2*(da*db + db*(1-da)^2 + da*(1-db^2) + (1-da)^2 - m(da, db)^2);

/******* verify p_A_less_B when db>da *******/
/* We substitute variables in general P(A<B) to get the simple formula, without Spears Robot cheating.
 * Then we compare it with manually calculated result for the simple formula.
 * It actually revealed a bug.
 */
assume(db>da);
/* In fact dx can be arbitrary here, because dh=dl. FIXME: check it */
if equal(subst([dx=0, dh=db, dl=db], p_A_less_B), p_A_less_B_simple) then OK else error("Incorrect result for the simple formula with db>da");
forget(db>da);
/********************************************/

/******* verify p_A_less_B when db<da *******/
assume(db<da);
/* In fact dx can be arbitrary here, because dh=dl. FIXME: check it */
if equal(subst([dx=0, dh=db, dl=db], p_A_less_B), p_A_less_B_simple) then OK else error("Incorrect result for the simple formula with db<da");
forget(db<da);
/********************************************/

/* Compute equilibrium. */
assume(db>da);
opt_db_given_da: solve(diff(subst([dx=0, dh=db, dl=db], p_A_less_B), db), db)[1];
/* In equilibrium we should have db = da, therefore: */
positive_equilibrium_solutions: sublist(solve(rhs(opt_db_given_da) = da), lambda([eq], rhs(eq) > 0));
d_eq: rhs(positive_equilibrium_solutions[1]);
if d_eq = (sqrt(5)-1)/2 then OK else error("equilibrium not as expected");
forget(db>da);

/* Simplifies expr assuming variables in vord are in increasing order. That is, if vord = [x1, x2, x3, ...],
 * assume_and_simplify() makes assumptions: x1 < x2 < x3 < ... and returns simplified expr. Variables in vord must not
 * be bound.
 */
assume_and_simplify(expr, vord) := (
    context:tempc,
    apply(assume, makelist(vord[i]<vord[i+1], i, length(vord)-1)),
    expr: ev(expr, noeval),
    killcontext(tempc),
    expr
);

/* Maybe p_A_less_B simplifies to a single formula? Let's check all possible orderings of variables. For each ordering,
 * we simplify it so that it no longer contains min/max.
 */
all_forms_of_p_A_less_B: {};
for order in permutations(['da, 'dx, 'dh, 'dl]) do (
    /* assume_and_simplify does a general simplification, we need to do rational simplification too. We use rat() to
     * make sure we get a canonical form to let us eliminate duplicates. */
    expr: rat(assume_and_simplify(p_A_less_B, order)),
    print("order", order, "gives p_A_less_B simplified to:", string(expr)),
    all_forms_of_p_A_less_B: adjoin(expr, all_forms_of_p_A_less_B),
    print("-------")
)$
all_forms_of_p_A_less_B: listify(all_forms_of_p_A_less_B)$
(
    print("There are", length(all_forms_of_p_A_less_B), "different forms of p_A_less_B depending on the order of",
        ['da, 'dx, 'dh, 'dl], "vars."),
    print("These are:"),
    for i: 1 thru length(all_forms_of_p_A_less_B) do display(all_forms_of_p_A_less_B[i])
)$

/* Because p_A_less_B does not have a single form that does not contain min/max and Maxima is unable to compute diff
 * value in a given point when a function contains min/max (or conditional expressions), we need to define a helper
 * assume_and_eval() that simplifies an expression knowing a point at which it needs to be computed, and then it
 * evaluates the expression.
 */
order_ev(x, y) := ev(x) < ev(y);
assume_and_eval(da, dx, dh, dl, expr) := block([vord:sort(['da, 'dx, 'dh, 'dl], 'order_ev)],
    context:tempc,
    /* simplify expr, but don't evaluate it yet - use fresh variables */
    expr:block([da, dx, dh, dl],
        /* for assume() we need not bound variables, otherwise it will treat the facts as redundant */
        apply(assume, makelist(vord[i]<vord[i+1], i, length(vord)-1)),
        expr:ev(expr, noeval),
        ev(expr, diff)
    ),
    killcontext(tempc),
    ev(expr)
);

/* Maxima 5.46.0 has a bug with 3d plots:
set pm3d hidden3d 100 border lw 0.5 lt rgb "#000000"
                  ^
"/tmp/maxout12350.gnuplot" line 9: invalid pm3d option
*/
plot3d(subst([dx=0, dh=db, dl=db], p_A_less_B), [da, 0, 1], [db, 0, 1]);
/* When Maxima is started in batch mode like: maxima -b <file>
 * then without the read(), it might not show the plot at all before quitting. In fact, gnuplot process is left running
 * when Maxima exits (that's the  case for gnuplot_pipes).
 */
/* read("just after plot3d"); */

grad_da(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, diff(p_A_less_B, 'da))$
grad_dx(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, diff(p_A_less_B, 'dx))$
grad_dh(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, diff(p_A_less_B, 'dh))$
grad_dl(da, dx, dh, dl) := assume_and_eval(da, dx, dh, dl, diff(p_A_less_B, 'dl))$

/* A not working "straightforward" evaluation of a diff of our expression, used as a demonstration. */
grad_da_BAD(da, dx, dh, dl) := at(diff(p_A_less_B, 'da), ['da=da, 'dx=dx, 'dh=dh, 'dl=dl])$

if grad_da(0.5, 0, 0.5, 0.5) = -0.125 then OK else error("expected grad_da to work for the first point");
/* Surprisingly, for this simple point even the "bad" function works. */
if grad_da_BAD(0.5, 0, 0.5, 0.5) = -0.125 then OK else error("expected grad_da_BAD to work for the first point");

if grad_da(1/2, 1/3, 5/8, 1/2) = -9/128 then OK else error("expected grad_da to work for the second point");
/* But it does not work for this one. */
if not numberp(grad_da_BAD(1/2, 1/3, 5/8, 1/2)) then OK else error("expected grad_da_BAD to FAIL for the second point");

load("lbfgs");

/************************************************************************************************************************
 * Maximize P(A<B) by computing optimal dx, dh, dl for Spears Robot, assuming Java-lin still uses equilibrium (da=d_eq).
 * Since lbfgs does minimization, we do it for negated p_A_less_B.
 ***********************************************************************************************************************/
/* First a plot. Substituting da=d_eq we still have 3 variables, so we pick some arbitrary value of dx. */
plot3d(subst([da=d_eq, dx=0.6], p_A_less_B), [dh, 0, 1], [dl, 0, 1]);
spears_vars_estimate: lbfgs(subst(da=d_eq, [-p_A_less_B, '[-grad_dx(da, dx, dh, dl), -grad_dh(da, dx, dh, dl), -grad_dl(da, dx, dh, dl)]]), [dx, dh, dl], [0.5, 0.5, 0.5], 1e-4, [1, 0]);
/*
   I  NFN     FUNC                    GNORM                   STEPLENGTH

   1    3    -5.018703144690373D-01   6.229903853601900D-02   1.253157352396802D+00  
...
  13   26    -5.069660051307446D-01   8.711377098050442D-05   6.698146201515560D-01  

 THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
 IFLAG = 0
(%o52) [dx = 0.6181829933081895, dh = 0.6911577540600441, 
                                                        dl = 0.500048602204644]
*/

spears_vars_estimate_with_javalin_equilibrium: cons(da=d_eq, spears_vars_estimate)$
if ev(is(dl<da and da<=dx and dx<dh), spears_vars_estimate_with_javalin_equilibrium) then OK else error("region of optimum for Spears vars not as expected");

/* Solve analytically for Spears Robot.
 * We need to evaluate our formula with assumptions as for the expected region of optimum. Actually we need to make a
 * stronger assumption, with strict inequalities, otherwise the expression won't get simplified.
 */
context:tempc;
assume(dl<da and da<dx and dx<dh);
print("Solving analytically for Spears Robot with assumptions:", facts())$
/* Note: we need to simplify before substitution, when da is still there. */
expr: ratsimp(subst(da=d_eq, ev(p_A_less_B, noeval)));
spears_solutions_unverified: radcan(solve(makelist(diff(expr, x), x, [dx, dh, dl]), [dx, dh, dl]));
killcontext(tempc);

spears_solution: [];
/* Filter analytic solutions to find the one that satisfies assumptions. */
for sol in spears_solutions_unverified do (
    sol_all_vars: cons(da=d_eq, sol),
    print("Checking analytic solution for Spears Robot:", ev(sol_all_vars, numer)),
    if ev(is(dl<da and da<=dx and dx<dh), sol_all_vars) then block([prob_spears],
        prob_spears: ev(ev(p_A_less_B, sol_all_vars), numer),
        print("Found a valid Spears Robot solution where winning probability for Spears Robot is:", prob_spears),
        spears_solution: cons(sol, spears_solution)
    ),
    print("-------")
)$
if length(spears_solution) = 1 then OK else error("unexpected length of spears_solution");
spears_solution: spears_solution[1];

/************************************************************************************************************************
 * We now need to maximize probability for Java-lin, which is 1-P(A<B), by minimizing P(A<B) over da, using previously
 * computed optimal (for Spears Robot) dx, dh, dl, stored in spears_solution.
 ***********************************************************************************************************************/
plot2d(subst(spears_solution, p_A_less_B), [da, 0, 1]);
javalin_var_estimate: lbfgs(subst(spears_solution, [p_A_less_B, '[grad_da(da, dx, dh, dl)]]), [da], [0.5], 1e-4, [1, 0]);
/*
   I  NFN     FUNC                    GNORM                   STEPLENGTH

   1    3     5.060808580483095D-01   7.337931512074875D-03   7.058023013977328D-01  
   2    4     5.060629096353509D-01   8.326672684688674D-17   1.000000000000000D+00  

 THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
 IFLAG = 0
(%o66)                     [da = 0.5833333333333334]
*/

javalin_var_estimate_with_spears_solution: cons(javalin_var_estimate, spears_solution)$
if ev(is(dl<da and da<=dx and dx<dh), javalin_var_estimate_with_spears_solution) then OK else error("region of optimum for Java-lin var not as expected");

/* Solve analytically for Java-lin. */
context:tempc;
assume(dl<da and da<dx and dx<dh);
print("Solving analytically for Java-lin with assumptions:", facts())$
expr: ratsimp(subst(spears_solution, ev(p_A_less_B, noeval)));
javalin_solutions_unverified: radcan(solve(makelist(diff(expr, x), x, [da]), [da]));
killcontext(tempc);

javalin_solution: [];
/* Filter analytic solutions to find the one that satisfies assumptions. */
for sol in javalin_solutions_unverified do (
    sol_all_vars: cons(sol, spears_solution),
    print("Checking analytic solution for Java-lin:", ev(sol_all_vars, numer)),
    if ev(is(dl<da and da<=dx and dx<dh), sol_all_vars) then block([prob_spears],
        prob_spears: ev(ev(p_A_less_B, sol_all_vars), numer),
        print("Found a valid solution for adjusted Java-lin strategy where winning probability for Spears Robot is:", prob_spears),
        javalin_solution: cons(sol, javalin_solution)
    ),
    print("-------")
)$
if length(javalin_solution) = 1 then OK else error("unexpected length of javalin_solution");
javalin_solution: javalin_solution[1];

/************************************************************************************************************************
 * Print the final summary.
 ***********************************************************************************************************************/
(
    sol: cons(javalin_solution, spears_solution),
    print("Final solution for Java-lin:", ev(sol, numer)),
    prob_spears: ev(ev(p_A_less_B, sol), numer), /* for Spears Robot */
    prob_javalin_exact: ev(1 - p_A_less_B, sol), /* for Java-lin */
    prob_javalin_rounded: ev(round(prob_javalin_exact * 10^10) / 10^10, numer),
    print("Probability for Spears Robot is:", prob_spears),
    print("Probability for Java-lin is:", ratsimp(prob_javalin_exact), "which equals:", ev(prob_javalin_exact, numer)),
    print("Probability for Java-lin rounded to 10 places is:", prob_javalin_rounded),
    print("Assumptions satisfied:", ev(is(dl<da and da<=dx and dx<dh), sol)),
    print("-------")
)$

if prob_javalin_rounded = 0.4939370904 then OK else error("Java-lin final rounded probability not as expected");
